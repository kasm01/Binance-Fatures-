# ğŸ“Œ Gerekli KÃ¼tÃ¼phaneleri YÃ¼kleme
!pip install tweepy praw pytrends textblob beautifulsoup4 requests h2o optuna tensorflow transformers xgboost catboost fbprophet binance-connector torch torchtext

import os
import asyncio
import websockets
import requests
import json
import numpy as np
import pandas as pd
import time
import threading
import logging
import ta
import tensorflow as tf
import torch
import optuna
import h2o
import xgboost as xgb
from catboost import CatBoostRegressor
import tweepy
import praw
from pytrends.request import TrendReq
from textblob import TextBlob
from bs4 import BeautifulSoup
from h2o.automl import H2OAutoML
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from transformers import TFTForSequenceClassification
from sklearn.preprocessing import MinMaxScaler
from fbprophet import Prophet
from google.cloud import storage
from google.colab import auth
from binance.client import Client
from binance.enums import ORDER_TYPE_MARKET, SIDE_BUY, SIDE_SELL
from telegram import Bot
from datetime import datetime, timedelta

# ğŸ“Œ Google Cloud Kimlik DoÄŸrulama
auth.authenticate_user()
storage_client = storage.Client()

# ğŸ“Œ API AnahtarlarÄ±
API_KEY = os.getenv("API_KEY")
API_SECRET = os.getenv("API_SECRET")
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")

client = Client(API_KEY, API_SECRET, testnet=True)
bot = Bot(token=TELEGRAM_BOT_TOKEN)

# ğŸ“Œ AI Ã–ÄŸrenme DosyasÄ±nÄ± Google Cloudâ€™a Kaydetme
LEARNING_FILE = "/content/drive/MyDrive/trading_data.csv"

# ğŸ“Œ Log AyarlarÄ±
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# ğŸ“Œ Piyasa Verisini Ã‡ekme Fonksiyonu
def get_market_data(symbol):
    klines = client.get_klines(symbol=symbol, interval=Client.KLINE_INTERVAL_1HOUR, limit=50)
    df = pd.DataFrame(klines, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['close'] = df['close'].astype(float)
    df['volume'] = df['volume'].astype(float)
    return df

# ğŸ“Œ Teknik GÃ¶stergeleri ve Model Ã–n Ä°ÅŸlemesini Yapma
def preprocess_data(df):
    df['atr'] = ta.volatility.AverageTrueRange(df['high'], df['low'], df['close']).average_true_range()
    df['rsi'] = ta.momentum.RSIIndicator(df['close']).rsi()
    df['macd'] = ta.trend.MACD(df['close']).macd()
    
    df.fillna(0, inplace=True)
    return df[['close', 'atr', 'rsi', 'macd']]

# ğŸ“Œ AI Modeli EÄŸitme (LSTM + TFT + XGBoost + CatBoost)
def train_ai_model():
    df = pd.read_csv(LEARNING_FILE)
    df = preprocess_data(df)

    scaler = MinMaxScaler()
    df_scaled = scaler.fit_transform(df)

    X, y = [], []
    for i in range(50, len(df_scaled)):
        X.append(df_scaled[i-50:i])
        y.append(df_scaled[i, 0])

    X, y = np.array(X), np.array(y)
    X = np.reshape(X, (X.shape[0], X.shape[1], 1))

    # ğŸ“Œ LSTM Modeli
    lstm_model = Sequential([
        LSTM(units=128, return_sequences=True, input_shape=(X.shape[1], 1)),
        Dropout(0.2),
        LSTM(units=128),
        Dropout(0.2),
        Dense(1)
    ])
    lstm_model.compile(optimizer='adam', loss='mean_squared_error')
    lstm_model.fit(X, y, epochs=15, batch_size=32, verbose=0)

    # ğŸ“Œ TFT Transformer Modeli
    tft_model = TFTForSequenceClassification.from_pretrained("huggingface/transformers")
    optimizer = torch.optim.Adam(tft_model.parameters(), lr=0.001)
    loss_fn = torch.nn.MSELoss()

    for epoch in range(15):
        optimizer.zero_grad()
        outputs = tft_model(torch.tensor(X, dtype=torch.float32))
        loss = loss_fn(outputs.logits.view(-1), torch.tensor(y, dtype=torch.float32))
        loss.backward()
        optimizer.step()

    # ğŸ“Œ XGBoost Modeli
    xgb_model = xgb.XGBRegressor(n_estimators=200, learning_rate=0.01, max_depth=6)
    xgb_model.fit(X.reshape(X.shape[0], -1), y)

    # ğŸ“Œ CatBoost Modeli
    catboost_model = CatBoostRegressor(iterations=200, learning_rate=0.01, depth=6, verbose=0)
    catboost_model.fit(X.reshape(X.shape[0], -1), y)

    logging.info("âœ… AI Modeli EÄŸitildi (LSTM + TFT + XGBoost + CatBoost)")
    return lstm_model, tft_model, xgb_model, catboost_model, scaler

# ğŸ“Œ AI Destekli Al-Sat Karar MekanizmasÄ±
def ai_decision(symbol, models, scaler):
    lstm_model, tft_model, xgb_model, catboost_model = models
    df = get_market_data(symbol)
    df = preprocess_data(df)

    X = scaler.transform(df)
    X = np.reshape(X, (X.shape[0], X.shape[1], 1))

    lstm_pred = lstm_model.predict(X)[-1]
    tft_pred = tft_model(torch.tensor(X, dtype=torch.float32)).logits.detach().numpy()[-1]
    xgb_pred = xgb_model.predict(X.reshape(X.shape[0], -1))[-1]
    catboost_pred = catboost_model.predict(X.reshape(X.shape[0], -1))[-1]

    final_prediction = (lstm_pred + tft_pred + xgb_pred + catboost_pred) / 4
    return "BUY" if final_prediction > df['close'].iloc[-1] else "SELL"

# ğŸ“Œ Binance WebSocket BaÄŸlantÄ±sÄ±
async def websocket_listener(symbol, models, scaler):
    uri = f"wss://stream.binance.com:9443/ws/{symbol.lower()}@trade"
    while True:
        try:
            async with websockets.connect(uri) as websocket:
                logging.info(f"âœ… WebSocket baÄŸlantÄ±sÄ± kuruldu: {symbol}")
                while True:
                    message = await websocket.recv()
                    decision = ai_decision(symbol, models, scaler)
                    if decision == "BUY":
                        logging.info(f"ğŸš€ {symbol}: AlÄ±m sinyali!")
                    elif decision == "SELL":
                        logging.info(f"ğŸ“‰ {symbol}: SatÄ±ÅŸ sinyali!")
        except Exception as e:
            logging.error(f"âŒ WebSocket hata verdi: {e}")
            await asyncio.sleep(5)

# ğŸ“Œ AI Modelini GÃ¼ncelleme ve WebSocket BaÅŸlatma
models, scaler = train_ai_model()
symbols = ["BTCUSDT", "ETHUSDT"]

for symbol in symbols:
    threading.Thread(target=lambda: asyncio.run(websocket_listener(symbol, models, scaler)), daemon=True).start()
