# 📌 Gerekli Kütüphaneleri Yükleme
!pip install tweepy praw pytrends textblob beautifulsoup4 requests h2o optuna tensorflow transformers xgboost catboost fbprophet binance-connector torch torchtext

import os
import asyncio
import websockets
import requests
import json
import numpy as np
import pandas as pd
import time
import threading
import logging
import ta
import tensorflow as tf
import torch
import optuna
import h2o
import xgboost as xgb
from catboost import CatBoostRegressor
import tweepy
import praw
from pytrends.request import TrendReq
from textblob import TextBlob
from bs4 import BeautifulSoup
from h2o.automl import H2OAutoML
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from transformers import TFTForSequenceClassification
from sklearn.preprocessing import MinMaxScaler
from fbprophet import Prophet
from google.cloud import storage
from google.colab import auth
from binance.client import Client
from binance.enums import ORDER_TYPE_MARKET, SIDE_BUY, SIDE_SELL
from telegram import Bot
from datetime import datetime, timedelta

# 📌 Google Cloud Kimlik Doğrulama
auth.authenticate_user()
storage_client = storage.Client()

# 📌 API Anahtarları
API_KEY = os.getenv("API_KEY")
API_SECRET = os.getenv("API_SECRET")
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")

client = Client(API_KEY, API_SECRET, testnet=True)
bot = Bot(token=TELEGRAM_BOT_TOKEN)

# 📌 AI Öğrenme Dosyasını Google Cloud’a Kaydetme
LEARNING_FILE = "/content/drive/MyDrive/trading_data.csv"

# 📌 Log Ayarları
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# 📌 Piyasa Verisini Çekme Fonksiyonu
def get_market_data(symbol):
    klines = client.get_klines(symbol=symbol, interval=Client.KLINE_INTERVAL_1HOUR, limit=50)
    df = pd.DataFrame(klines, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['close'] = df['close'].astype(float)
    df['volume'] = df['volume'].astype(float)
    return df

# 📌 Teknik Göstergeleri ve Model Ön İşlemesini Yapma
def preprocess_data(df):
    df['atr'] = ta.volatility.AverageTrueRange(df['high'], df['low'], df['close']).average_true_range()
    df['rsi'] = ta.momentum.RSIIndicator(df['close']).rsi()
    df['macd'] = ta.trend.MACD(df['close']).macd()
    
    df.fillna(0, inplace=True)
    return df[['close', 'atr', 'rsi', 'macd']]

# 📌 AI Modeli Eğitme (LSTM + TFT + XGBoost + CatBoost)
def train_ai_model():
    df = pd.read_csv(LEARNING_FILE)
    df = preprocess_data(df)

    scaler = MinMaxScaler()
    df_scaled = scaler.fit_transform(df)

    X, y = [], []
    for i in range(50, len(df_scaled)):
        X.append(df_scaled[i-50:i])
        y.append(df_scaled[i, 0])

    X, y = np.array(X), np.array(y)
    X = np.reshape(X, (X.shape[0], X.shape[1], 1))

    # 📌 LSTM Modeli
    lstm_model = Sequential([
        LSTM(units=128, return_sequences=True, input_shape=(X.shape[1], 1)),
        Dropout(0.2),
        LSTM(units=128),
        Dropout(0.2),
        Dense(1)
    ])
    lstm_model.compile(optimizer='adam', loss='mean_squared_error')
    lstm_model.fit(X, y, epochs=15, batch_size=32, verbose=0)

    # 📌 TFT Transformer Modeli
    tft_model = TFTForSequenceClassification.from_pretrained("huggingface/transformers")
    optimizer = torch.optim.Adam(tft_model.parameters(), lr=0.001)
    loss_fn = torch.nn.MSELoss()

    for epoch in range(15):
        optimizer.zero_grad()
        outputs = tft_model(torch.tensor(X, dtype=torch.float32))
        loss = loss_fn(outputs.logits.view(-1), torch.tensor(y, dtype=torch.float32))
        loss.backward()
        optimizer.step()

    # 📌 XGBoost Modeli
    xgb_model = xgb.XGBRegressor(n_estimators=200, learning_rate=0.01, max_depth=6)
    xgb_model.fit(X.reshape(X.shape[0], -1), y)

    # 📌 CatBoost Modeli
    catboost_model = CatBoostRegressor(iterations=200, learning_rate=0.01, depth=6, verbose=0)
    catboost_model.fit(X.reshape(X.shape[0], -1), y)

    logging.info("✅ AI Modeli Eğitildi (LSTM + TFT + XGBoost + CatBoost)")
    return lstm_model, tft_model, xgb_model, catboost_model, scaler

# 📌 AI Destekli Al-Sat Karar Mekanizması
def ai_decision(symbol, models, scaler):
    lstm_model, tft_model, xgb_model, catboost_model = models
    df = get_market_data(symbol)
    df = preprocess_data(df)

    X = scaler.transform(df)
    X = np.reshape(X, (X.shape[0], X.shape[1], 1))

    lstm_pred = lstm_model.predict(X)[-1]
    tft_pred = tft_model(torch.tensor(X, dtype=torch.float32)).logits.detach().numpy()[-1]
    xgb_pred = xgb_model.predict(X.reshape(X.shape[0], -1))[-1]
    catboost_pred = catboost_model.predict(X.reshape(X.shape[0], -1))[-1]

    final_prediction = (lstm_pred + tft_pred + xgb_pred + catboost_pred) / 4
    return "BUY" if final_prediction > df['close'].iloc[-1] else "SELL"

# 📌 Binance WebSocket Bağlantısı
async def websocket_listener(symbol, models, scaler):
    uri = f"wss://stream.binance.com:9443/ws/{symbol.lower()}@trade"
    while True:
        try:
            async with websockets.connect(uri) as websocket:
                logging.info(f"✅ WebSocket bağlantısı kuruldu: {symbol}")
                while True:
                    message = await websocket.recv()
                    decision = ai_decision(symbol, models, scaler)
                    if decision == "BUY":
                        logging.info(f"🚀 {symbol}: Alım sinyali!")
                    elif decision == "SELL":
                        logging.info(f"📉 {symbol}: Satış sinyali!")
        except Exception as e:
            logging.error(f"❌ WebSocket hata verdi: {e}")
            await asyncio.sleep(5)

# 📌 AI Modelini Güncelleme ve WebSocket Başlatma
models, scaler = train_ai_model()
symbols = ["BTCUSDT", "ETHUSDT"]

for symbol in symbols:
    threading.Thread(target=lambda: asyncio.run(websocket_listener(symbol, models, scaler)), daemon=True).start()
